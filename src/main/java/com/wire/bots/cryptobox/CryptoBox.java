// Copyright (C) 2022 Wire Swiss GmbH <support@wire.com>
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

package com.wire.bots.cryptobox;

import java.io.File;

/**
 * <p>
 * A {@code CryptoBox} is an opaque container of all the necessary key material
 * needed for exchanging end-to-end encrypted messages with peers for a single,
 * logical client or device. It maintains a pool of {@link CryptoSession}s for
 * all remote peers.
 * </p>
 * <p>Every cryptographic session with a peer is represented by a {@link CryptoSession}.
 * These sessions are pooled by a {@code CryptoBox}, i.e. if a session with the
 * same session ID is requested multiple times, the same instance is returned.
 * Consequently, {@code CryptoSession}s are kept in memory once loaded. They
 * can be explicitly closed through  or {@link CryptoBox}.
 * All loaded sessions are implicitly closed
 * when the {@code CryptoBox} itself is closed via {@link CryptoBox#close()}.
 * Note that it is considered programmer error to let a {@code CryptoBox}
 * become unreachable and thus eligible for garbage collection without having
 * called {@link CryptoBox#close()}, even though this class overrides {@link Object#finalize()}
 * as an additional safety net for deallocating all native resources.
 * </p>
 *
 * <p>A {@code CryptoBox} is thread-safe.</p>
 *
 * @see CryptoSession
 */
// we can safely ignore the creation of the directories
// as they either exist and we don't care, or the operation
// throws exception in the next steps
@SuppressWarnings("ResultOfMethodCallIgnored")
final public class CryptoBox implements ICryptobox {

    static {
        // It's called libsodium.dll on Windows, unfortunately.
        final String prefix = System
                .getProperty("os.name")
                .toLowerCase()
                .contains("win")
                ? "lib" : "";
        System.loadLibrary(prefix + "sodium");
        System.loadLibrary("cryptobox");
        System.loadLibrary("cryptobox-jni");
    }

    /**
     * The max ID of an ephemeral prekey generated by {@link #newPreKeys}.
     */
    private static final int MAX_PREKEY_ID = 65_534;
    private static final int LAST_RESORT_PREKEY_ID = MAX_PREKEY_ID + 1;

    private long ptr;

    private CryptoBox(long ptr) {
        this.ptr = ptr;
    }

    /**
     * Open a {@code CryptoBox} that operates on the given directory.
     * <p>
     * The given directory must exist and be writeable.
     * </p>
     * <p>Note: Do not open multiple boxes that operate on the same or
     * overlapping directories. Doing so results in undefined behaviour.</p>
     *
     * @param dir The root storage directory of the box.
     * @return opened cryptobox.
     * @throws CryptoException from native code if it was not possible to perform the operation.
     */
    public static CryptoBox open(String dir) throws CryptoException {
        errorOnNull(dir, "dir");

        new File(dir).mkdirs();
        return jniOpen(dir);
    }

    /**
     * Open a {@code CryptoBox} that operates on the given directory, using
     * an existing external identity.
     * <p>
     * The given identity must match the (public or complete) identity that
     * the {@code CryptoBox} already has, if any.
     * </p>
     * <p>The given directory must exist and be writeable.</p>
     * <p>Note: Do not open multiple boxes that operate on the same or
     * overlapping directories. Doing so results in undefined behaviour.</p>
     *
     * @param dir  The root storage directory of the box.
     * @param id   The serialised external identity to use.
     * @param mode The desired local identity storage.
     * @return opened cryptobox.
     * @throws IllegalStateException if {@code mode} is invalid.
     * @throws CryptoException       from native code if it was not possible to perform the operation.
     */
    public static CryptoBox openWith(String dir, byte[] id, IdentityMode mode) throws CryptoException {
        errorOnNull(dir, "dir");
        errorOnNull(id, "id");
        errorOnNull(mode, "mode");

        new File(dir).mkdirs();
        switch (mode) {
            case COMPLETE:
                return jniOpenWith(dir, id, 0);
            case PUBLIC:
                return jniOpenWith(dir, id, 1);
            default:
                throw new IllegalStateException("Unexpected IdentityMode");
        }
    }

    /**
     * Get the public key fingerprint from a prekey.
     *
     * @param preKey prekey to get the fingerprint from.
     * @return The HEX encoded fingerprint.
     * @throws CryptoException from native code if it was not possible to perform the operation.
     */
    public static byte[] getFingerprintFromPrekey(PreKey preKey) throws CryptoException {
        errorOnNull(preKey, "preKey");
        errorOnNull(preKey.data, "preKey.data");

        return jniGetFingerprintFromPrekey(preKey.data);
    }

    /**
     * Ensures that the given prekey is valid. Throws exception if the prekey is not valid.
     *
     * @param preKey prekey to validate.
     * @throws CryptoException          from native code if it is not valid prekey with {@link CryptoException#code} equals to
     *                                  {@link CryptoException.Code#DECODE_ERROR}.
     * @throws IllegalArgumentException if the {@link PreKey#id} is not valid.
     */
    public static void isPrekey(PreKey preKey) throws CryptoException {
        errorOnNull(preKey, "preKey");
        errorOnNull(preKey.data, "preKey.data");
        errorOnNull(preKey.id, "preKey.id");

        if (preKey.id < 0 || preKey.id > LAST_RESORT_PREKEY_ID) {
            throw new IllegalArgumentException("ID of the prekey must be 0 <= ID <= " + LAST_RESORT_PREKEY_ID + "!");
        }

        jniIsPreKey(preKey.data, preKey.id);
    }

    private native static CryptoBox jniOpen(String dir) throws CryptoException;

    private native static CryptoBox jniOpenWith(String dir, byte[] id, int mode) throws CryptoException;

    private native static byte[] jniGetFingerprintFromPrekey(byte[] prekey) throws CryptoException;

    private native static PreKey jniNewLastPreKey(long ptr) throws CryptoException;

    private native static PreKey[] jniNewPreKeys(long ptr, int start, int num) throws CryptoException;

    private native static byte[] jniGetLocalFingerprint(long ptr) throws CryptoException;

    private native static CryptoSession jniInitSessionFromPreKey(long ptr, String sid, byte[] prekey) throws CryptoException;

    private native static SessionMessage jniInitSessionFromMessage(long ptr, String sid, byte[] message) throws CryptoException;

    private native static CryptoSession jniLoadSession(long ptr, String sid) throws CryptoException;

    private native static void jniDeleteSession(long ptr, String sid) throws CryptoException;

    private native static byte[] jniCopyIdentity(long ptr) throws CryptoException;

    private native static void jniClose(long ptr);

    private native static void jniIsPreKey(byte[] prekey, int prekeyId) throws CryptoException;


    /**
     * Copy the long-term identity from this {@code CryptoBox}.
     *
     * @return The opaque, serialised identity to be stored in a safe place or
     * transmitted over a safe channel for subsequent use with
     * {@link CryptoBox#openWith}.
     */
    @Override
    public byte[] getIdentity() throws CryptoException {
        errorIfClosed();
        return jniCopyIdentity(ptr);
    }

    /**
     * Get the local fingerprint as a hex-encoded byte array.
     */
    @Override
    public byte[] getLocalFingerprint() throws CryptoException {
        errorIfClosed();
        return jniGetLocalFingerprint(ptr);
    }

    /**
     * Generate a new last prekey.
     * <p>
     * The last prekey is never removed as a result of {@link #initSessionFromMessage}.
     */
    @Override
    public PreKey newLastPreKey() throws CryptoException {
        errorIfClosed();
        return jniNewLastPreKey(ptr);
    }

    private static void errorOnNull(Object data, String paramName) {
        if (data == null) {
            throw new IllegalArgumentException(String.format("Parameter \"%s\" can't be null!", paramName));
        }
    }

    /**
     * Generate a new batch of ephemeral prekeys.
     * <p>
     * If {@code start + num {@literal >} {@link #MAX_PREKEY_ID}} the IDs wrap around and start
     * over at 0. Thus after any valid invocation of this method, the last generated
     * prekey ID is always {@code (start + num) % ({@link #MAX_PREKEY_ID} + 1)}. The caller
     * can remember that ID and feed it back into this method as the start
     * ID when the next batch of ephemeral keys needs to be generated.
     *
     * @param start The ID ({@literal >}= 0 and {@literal <}= {@link #MAX_PREKEY_ID}) of the first prekey to generate.
     * @param num   The total number of prekeys to generate ({@literal >} 0 and {@literal <}= {@link #MAX_PREKEY_ID}).
     */
    @Override
    public PreKey[] newPreKeys(int start, int num) throws CryptoException {
        errorIfClosed();
        if (start < 0 || start > MAX_PREKEY_ID) {
            throw new IllegalArgumentException("start must be >= 0 and <= " + MAX_PREKEY_ID);
        }
        if (num < 1 || num > MAX_PREKEY_ID) {
            throw new IllegalArgumentException("num must be >= 1 and <= " + MAX_PREKEY_ID);
        }
        return jniNewPreKeys(ptr, start, num);
    }

    /**
     * Inits the session from the prekey and encrypts the given content
     *
     * @param sid     Identifier in our case: userId_clientId
     * @param content Unencrypted binary content to be encrypted
     * @return Cipher
     * @throws CryptoException throws Exception
     */
    @Override
    public byte[] encryptFromPreKeys(String sid, PreKey preKey, byte[] content) throws CryptoException {
        errorOnNull(sid, "sid");
        errorOnNull(preKey, "preKey");
        errorOnNull(content, "content");

        try (final CryptoSession cryptoSession = initSessionFromPreKey(sid, preKey)) {
            return cryptoSession.encrypt(content);
        }
    }

    /**
     * Tries to fetch/open a session for the given sid if it exists on the hdd and encrypts the given content
     *
     * @param sid     Identifier in our case: userId_clientId
     * @param content Unencrypted binary content to be encrypted
     * @return Cipher or NULL in case there is no session for the given {@code sid}
     * @throws CryptoException throws Exception
     */
    @Override
    public byte[] encryptFromSession(String sid, byte[] content) throws CryptoException {
        errorOnNull(sid, "sid");
        errorOnNull(content, "content");

        try (final CryptoSession session = tryGetSession(sid)) {
            if (session != null) {
                return session.encrypt(content);
            }
        }
        return null;
    }

    /**
     * Decrypt cipher either using existing session or it creates new session from this cipher and decrypts
     *
     * @param sid    Session Id
     * @param cipher cipher
     * @return Decrypted bytes
     * @throws CryptoException throws Exception
     */
    @Override
    public byte[] decrypt(String sid, byte[] cipher) throws CryptoException {
        errorOnNull(sid, "sid");
        errorOnNull(cipher, "cipher");

        try (final CryptoSession cryptoSession = tryGetSession(sid)) {
            if (cryptoSession != null) {
                return cryptoSession.decrypt(cipher);
            }
        }

        try (SessionMessage sessionMessage = initSessionFromMessage(sid, cipher)) {
            return sessionMessage.getMessage();
        }
    }

    /**
     * Initialise a {@link CryptoSession} using the prekey of a peer.
     * <p>
     * <p>This is the entry point for the initiator of a session, i.e.
     * the side that wishes to send the first message.</p>
     *
     * @param sid    The ID of the new session.
     * @param prekey The prekey of the peer.
     */
    private CryptoSession initSessionFromPreKey(String sid, PreKey prekey) throws CryptoException {
        errorIfClosed();
        errorOnNull(sid, "sid");
        errorOnNull(prekey, "prekey");
        errorOnNull(prekey.data, "prekey.data");

        return jniInitSessionFromPreKey(ptr, sid, prekey.data);
    }

    /**
     * Initialise a {@link CryptoSession} using a received encrypted message.
     * <p>
     * <p>This is the entry point for the recipient of an encrypted message.</p>
     *
     * @param sid     The ID of the new session.
     * @param message The encrypted (prekey) message.
     */
    private SessionMessage initSessionFromMessage(String sid, byte[] message) throws CryptoException {
        errorIfClosed();
        errorOnNull(sid, "sid");
        errorOnNull(message, "message");

        return jniInitSessionFromMessage(ptr, sid, message);
    }

    /**
     * Get an existing session by ID.
     * <p>
     * <p>If the session does not exist, a {@link CryptoException} is thrown
     * with the code {@link CryptoException.Code#SESSION_NOT_FOUND}.</p>
     * </p>
     *
     * @param sid The ID of the session to get.
     */
    private CryptoSession getSession(String sid) throws CryptoException {
        errorIfClosed();
        errorOnNull(sid, "sid");
        return jniLoadSession(ptr, sid);
    }

    /**
     * Determines whether the requested session exist or not.
     *
     * @param sid The ID of the session.
     * @return true if the given session ID exists, false otherwise.
     * @throws CryptoException thrown when there's a problem with native Cryptobox.
     */
    public boolean doesSessionExist(String sid) throws CryptoException {
        return tryGetSession(sid) != null;
    }

    /**
     * <p>Try to get an existing session by ID.</p>
     *
     * <p>Equivalent to {@link #getSession}, except that <tt>null</tt> is
     * returned if the session does not exist.</p>
     *
     * @param sid The ID of the session to get.
     */
    private CryptoSession tryGetSession(String sid) throws CryptoException {
        errorOnNull(sid, "sid");
        try {
            return getSession(sid);
        } catch (final CryptoException ex) {
            if (ex.code == CryptoException.Code.SESSION_NOT_FOUND) {
                return null;
            }
            throw ex;
        }
    }

    /**
     * Close the {@code CryptoBox}.
     *
     * <p>Note: After a box has been closed, any operations other than
     * {@code close} are considered programmer error and result in
     * an {@link IllegalStateException}.</p>
     *
     * <p>If the box is already closed, this is a no-op.</p>
     */
    @Override
    public void close() {
        if (ptr == 0) {
            return;
        }
        jniClose(ptr);
        ptr = 0;
    }

    public boolean isClosed() {
        return ptr == 0;
    }

    private void errorIfClosed() {
        if (ptr == 0) {
            throw new IllegalStateException("Invalid operation on a closed CryptoBox.");
        }
    }

    /**
     * Delete a session.
     * <p>
     * If the session is currently loaded, it is automatically closed before
     * being deleted.
     * </p>
     * <p>Note: After a session has been deleted, further messages received from
     * the peer can no longer be decrypted. </p>
     *
     * @param sid The ID of the session to delete.
     */
    private void deleteSession(String sid) throws CryptoException {
        errorIfClosed();
        errorOnNull(sid, "sid");

        final CryptoSession cryptoSession = getSession(sid);
        if (cryptoSession != null) {
            cryptoSession.close();
        }
        jniDeleteSession(ptr, sid);
    }

    @Override
    protected void finalize() {
        close();
    }

    /**
     * The desired local storage mode for use with {@link #openWith}.
     */
    public enum IdentityMode {
        COMPLETE, PUBLIC
    }
}
